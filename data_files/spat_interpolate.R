spat_interpolate <- function(object, train, test){
  #Take spatial minima and maxima
  xmin <- min(object[,2])
  xmax <- max(object[,2])
  ymin <- min(object[,3])
  ymax <- max(object[,3])
  
  #Global data
  glob1r<-data.frame(cbind((object[,2]-xmin)/abs(xmax-xmin),(object[,3]-ymin)/abs(ymax-ymin)))
  #Species training data
  spr<-data.frame(cbind((train[train[,1]==1,2]-xmin)/abs(xmax-xmin),(train[train[,1]==1,3]-ymin)/abs(ymax-ymin)))
  #Spatial grid
  R <- 100
  xy <- cbind((1:R)/R,(1:R)/R)
  xy <- SpatialPoints(xy)
  mask<-ascgen(xy,nrcol=R,count=F)
  spr_xy <- SpatialPoints(spr)
  #Estimation of Utilization Distribution
  KernelEStimation=kernelUD(spr_xy,  kern = c("bivnorm"),grid=mask)
  #image(KernelEStimation, axes = FALSE)
  #Convert to raster
  sp.dens <- raster(as(KernelEStimation,"SpatialPixelsDataFrame"))
  
  #Repeat for global data
  glob1r_xy <- SpatialPoints(glob1r)
  KernelEStimationGlobal<-kernelUD(glob1r_xy,grid=mask,kern="bivnorm")
  global.dens <- raster(as(KernelEStimationGlobal,"SpatialPixelsDataFrame"))
  
  ##Extrating testing
  # All xy points in testing data
  spr_test<-data.frame(cbind((test[,2]-xmin)/abs(xmax-xmin),(test[,3]-ymin)/abs(ymax-ymin)))
  Sp_predictions=extract(sp.dens, spr_test)#extract points from raster, points are density of a species
  Global_predictions=extract(global.dens, spr_test)#extract points from raster, points are density of the sampling points
  
  z <- Sp_predictions*(nrow(train[train[,1]==1,]))/ (sum(Sp_predictions, na.rm=T)) #rescale density to the number of occurrences in sp
  Z <- Global_predictions*(nrow(train))/ sum(Global_predictions, na.rm=T) #rescale density to the number of sites in glob1 (scale according to the training data only as it is the base for the model building)
  
  # remove infinitesimally small number generated by kernel density function
  z[z<max(z)/1000]<-0
  # remove infinitesimally small number generated by kernel density function
  Z[Z<max(Z)/1000]<-0
  # correct for environment prevalence
  z <- z/Z
  # remove n/0 situations
  z[is.na(z)] <- 0
  # remove n/0 situations
  z[z=="Inf"] <- 0
  # rescale between [0:1] for comparison with other species
  z.cor<-z/max(z)
  
  #tallying up predictions for all species
  TestPredictions=as.data.frame(z.cor)
  TestPredictions=cbind(test[,1], TestPredictions)
  colnames(TestPredictions)=c("X","L")
  
  return(TestPredictions$L)
}